<!DOCTYPE html>
<html>
  <head>
    <title>Simulacion de nieve</title>
      <style>
      <style>
            html, body { margin: 0; padding: 0; overflow: hidden; }
            #info {
                position: absolute;
                width: 100%;
                text-align: center;
                color: #FFFFFF;
            }
        </style>
  </head>
  <body>

  
   <!--Librerias de graficacion-->
    <script src="js/three.min.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script src="js/controls/OrbitControls.js"></script>
    
    <!--Librerias algebraicas para matrices-->
    <script src="https://unpkg.com/svd-js" type="application/javascript"></script>
    <script src="https://unpkg.com/lightmatrix/dist/lightmatrix.js"></script>
     
    <!--Librerias para la simulacion-->
    <script src="Set.js"></script>
    <script src="Escena.js"></script>
    <script src= "CrearEsferaParticulas.js"></script>
    <script src="OperacionesVectoresMatrices.js"></script>
    <script src="ParametrosFisicos.js"></script>
    <script src="Interpolacion.js"></script>
    <script src="Particula.js"></script>
    <script src="Fuerzas.js"></script>
    <script src="Grid.js"></script>
    <script src="Planos.js"></script>
    <script src="PlanosPrueba.js"></script>
    <script src="Simulacion.js"></script>
   <!-- <script src="main.js"></script>-->
    
    <script>
    //Creacion de atributos de la simulacion
    var frames_per_second = 30;
    var delta_t = 1e-3;

    // Parametros fisicos
    var E_0 = 1.4e5;            // Young's modulus
    var nu = 0.2;               // Poisson's ratio
    var xi = 10;                // Hardening coefficient
    var theta_c = 2.5e-2;       // Critical compression
    var theta_s = 7.5e-3;       // Critical stretch
    var alpha = 0.95;           // FLIP/PIC ratio

    var mu = 1.0; // static friction

    var num_particulas = 1e-3;

    n_func_init();
    n_func_derivative_init();

        
    var res_x = 30;
    var res_y = 30;
    var res_z = 30;
    var dim = new THREE.Vector3(res_x, res_y, res_z);
    var h = 5 / res_y;

    //Creacion de objetos    
    var grid = new Grid(res_x, res_y, res_z, h);
    var parametros = new ParametrosFisicos(E_0, nu, xi, theta_c, theta_s, alpha);
    var nievesim = new Simulacion(frames_per_second, delta_t, parametros);   
    nievesim.cargarGrid(grid);

    var mundoalmodelo = new THREE.Matrix4();
    mundoalmodelo = trasladarMat4(mundoalmodelo,new THREE.Vector3(grid.dim_x / 2, 0, grid.dim_z / 2));    
    //mundoalmodelo = trasladarMat4(mundoalmodelo,new THREE.Vector3(grid.dim_x / 2, grid.dim_y / 2, grid.dim_z / 2));    
    var modeloalmundo = new THREE.Matrix4();
    modeloalmundo = trasladarMat4(modeloalmundo,new THREE.Vector3(-grid.dim_x / 2, 0, -grid.dim_z / 2));
    //modeloalmundo = trasladarMat4(modeloalmundo,new THREE.Vector3(-grid.dim_x / 2, -grid.dim_y / 2, -grid.dim_z / 2));


    //Se crean las particulas de la simulacion
    var radio = Math.pow(3 * num_particulas / (16 * Math.PI), 1/3) * h;
    CrearEsferaParticulas(grid,num_particulas,radio);
        
    //Array que guarda las colisiones
    var objetos = new Array();
	
	init();
	animate();
    render();
		
	function init(){
        
        //Creacion de la escena 3D
        creacion();
        
        
        //Construccion de la caja que contendra la simulacion
        var mu = 0.2;
        var color_suelo = new THREE.Color(0x544F4F); //Color del suelo
        var origen = new THREE.Vector3(-1 * grid.dim_x/2,0, -1 * grid.dim_z/2);//(-2.5,0,-2.5)
        //var origen = new THREE.Vector3(-1 * grid.dim_x/2,-1*grid.dim_y/2, -1 * grid.dim_z/2);//(-2.5,0,-2.5)
        var eje_x = new THREE.Vector3(grid.dim_x,0,0);//(5,0,0)
        var eje_y = new THREE.Vector3(0,grid.dim_y,0);//(0,5,0)
        var eje_z = new THREE.Vector3(0,0,grid.dim_z);//(0,0,5)
        //Suelo
        var suelo = new Planos(origen,eje_x,eje_z,mu,modeloalmundo,mundoalmodelo,color_suelo);
        //Caras
        var color_caras = new THREE.Color(0xD7C3F3);
        var o_eje_x = sumaVec3(origen,eje_x);
        var o_eje_z = sumaVec3(origen,eje_z);
        var cara_1 = new Planos(origen,eje_x,eje_y,mu,modeloalmundo,mundoalmodelo,color_caras);//cara en -z
        var cara_2 = new Planos(origen,eje_z,eje_y,mu,modeloalmundo,mundoalmodelo,color_caras);//cara en -x
        var cara_3 = new Planos(o_eje_x,eje_y,eje_z,mu,modeloalmundo,mundoalmodelo,color_caras);//cara en x
        var cara_4 = new Planos(o_eje_z,eje_x,eje_y,mu,modeloalmundo,mundoalmodelo,color_caras);//cara en z

        //cargamos los objetos en el array 
        objetos.push(suelo);
        objetos.push(cara_1);
        objetos.push(cara_2);
        objetos.push(cara_3);
        objetos.push(cara_4);

        //Construccion de la cuña
        var color_cunia = new THREE.Color('skyblue');
        var esquina =  new THREE.Vector3(0,grid.dim_y/2,-grid.dim_z/2.5);//(0,2.5,-2)
        //var esquina =  new THREE.Vector3(0,-0.05*grid.dim_y/2,-grid.dim_z/2);//(0,2.5,-2)
        var borde_superior = new THREE.Vector3(0, 0, 0.8 * grid.dim_z);//(0,0,4)
        var borde1 = new THREE.Vector3(0.15*grid.dim_x, -0.15*grid.dim_y, 0);//(0.75,-0.75,0)
        var borde2 = new THREE.Vector3(-0.15*grid.dim_x, -0.15*grid.dim_y, 0);//(-0.75,-0.75,0)
        //var borde3 = new THREE.Vector3(0.75, 0.75, 0);
        var cunia_1 = new Planos(esquina,borde1,borde_superior,mu,modeloalmundo,mundoalmodelo,color_cunia);
        var cunia_2 = new Planos(esquina,borde_superior,borde2,mu,modeloalmundo,mundoalmodelo,color_cunia);
        
        //cargamos las cuñas al array 
        objetos.push(cunia_1);
        objetos.push(cunia_2);
        
        //Se cargan los metodo de la simulacion
        nievesim.cargarModeloalmundo(modeloalmundo);
        nievesim.cargarColisionObjeto(objetos);
        nievesim.dibujarContenido();  
        
            var grad_vp = new THREE.Matrix3
            grad_vp.set(-102.71756968759635, -2.785804803204193e-16, 1.1742039229938061e-15,
             2.83221239297499e-15, -105.8934771504573, -1.6842593304435043e-15,
            -6.303150546018655e-16, -1.6842390016527702e-15, -102.45216014730178);

	       var identity = new THREE.Matrix3();

	       var dgrad_E_next = new THREE.Matrix3();
            dgrad_E_next.set(0.8972824303124036, -2.7858048032041935e-19, 1.174203922993806e-18,
                             2.83221239297499e-18, 0.8941065228495427, -1.6842593304435044e-18,
						    -6.303150546018655e-19, -1.6842390016527702e-18, 0.8975478398526983);

	       var F_next = new THREE.Matrix3(); 
            F_next.set(0.8972824303124036, -2.7858048032041935e-19, 1.174203922993806e-18,
                       2.83221239297499e-18, 0.8941065228495427, -1.6842593304435044e-18,
					   -6.303150546018655e-19, -1.6842390016527702e-18, 0.8975478398526983);

	       var deformation_grad_E = new THREE.Matrix3();
	       var deformation_grad_P = new THREE.Matrix3();
        
            var matPrueba = new THREE.Matrix3();
            matPrueba.set(5, 4, 3,
		                  2, 6, 7,
		                  4, 2, 4);
           var dgrad_E_svd = three_a_svdjs(matPrueba);
           var { u, v, q } = SVDJS.SVD(dgrad_E_svd);
           var U = svdjs_a_three(u);
           var V = svdjs_a_three(v);
            console.log("U: ",U);
            console.log("V: ",V);
           var S_hat_vec = svdjs_a_threeVector3(q);
           console.log("S_hat_vec: ",S_hat_vec);
           var S_vec = Vec3ClampScalar(S_hat_vec,1 - theta_c, 1 + theta_s);
           
           var S = new THREE.Matrix3();
           S.set(S_vec.x,0,0,
                 0,S_vec.y,0,
                 0,0,S_vec.z);
           
           var S_inv = new THREE.Matrix3();
           S_inv.set(1/S_vec.x,0,0,
                     0,1/S_vec.y,0,
                     0,0,1/S_vec.z);
           

           deformation_grad_P = mulMatriz3(mulMatriz3(U,S),transpuestaMat3(V));
           console.log("G_deformacion_E_1: ",deformation_grad_P);
           deformation_grad_E = mulMatriz3(mulMatriz3(mulMatriz3(V,S_inv),transpuestaMat3(U)),F_next);
           console.log("G_deformacion_P: ",deformation_grad_E);
    }    

	function render(){
      nievesim.eliminarObjetosEscena();
      nievesim.dibujarContenido();  
    }
        
    function animate() {
        requestAnimationFrame( animate );
        renderer.render( scene, camera );
        render();
	}
	
	
    </script>
  </body>
</html>